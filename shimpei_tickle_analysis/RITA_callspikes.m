%  #############################################
%% #####       RITA Spike histogram        #####
%  #############################################
%  Brecht Lab                         13.11.2013
%
%  >>> calls vs. Spikes, Version 1.0
%  This tool gathers Spike and USV data from RITA and adds it up to a
%  histogram. Several filter options are available in a separate window.
%  The core of the script is a multi-dimensional spike matrix that can be
%  saved and reused.
% 
%  Have fun exploring the programm, script and your Recording data!! 
%  Your feedback and questions are welcome (falk.mielke@bccn-berlin.de).
% 
% 
% INPUT PARAMETER:
%  - sessions (examples: '71'(single) or '1,10,736'(multiple))
% 
%  _____________________________________________
%%  Table Of Content
%	I. Preparation
%	II. main function
%       A: The Histogram
%       B: STC and Spikes Data
%       C: Filter Lists GUI
% 	III. GUI callbacks
% 	IV. The Spike Machinery
%       A: Add Spikes
%       B: Staple Up Histogram
%       C: Multi-Dimensional Operations
% 	V. Keep Your Histogram Beautiful
% 	VI. SQL queries to RITA
%       A: Load USV Data
%       B: Spikes from RITA
%       C: Misc Short Queries
%  _____________________________________________
%  NOTES for Programmers:
%  - use MATLAB "show cell titles" button to navigate
% 
%  - Dimensions of the "spike" and "calls" matrices:
%     1) cluster (from STC)
%     2) bin (time vs time of call)
%     3) recording
%     4) call type
%     5) emitter (from calls)
%     6) emitter sex (from calls)
%    ( all are used for filtering; 
%       spikes are saved this way and useless if changes occur);
% 
%  - please keep documentation updated!
% 
% 
%  TODO: get stimulus info (estrous as example) 
%  TODO: dynamic histogram x-axis
%  TODO: consider adding functionality to add single sessions
%  TODO: save and load while working (with filters)
%  TODO: cleanup filters struct (uniform "string", "nums", "actives" for 
%        each filter dimension)
% 
%% _____________________________________________



function RITA_callspikes (sessions)

%% _____________________________________________
%% --- I. Preparation ---
%% . enter variables
    % event trigger
    trigger = 'start'; % end
    
    % histogram xaxis
    t_minus = -200;     % -240  ||  -500
    t_plus =   200;     %  400  ||  1000
    bin_count = 40;     %   50  ||    50
    binsize = (t_plus - t_minus)/bin_count;
    timeinterval = linspace(t_minus,t_plus,bin_count+1);
    tick = floor((bin_count)/10); % length of a tick [bars]
    
    % mysql connection
%         mysqlconnect('falk_RITA');
%     if(mysql('status'))
mysql('open','mysql','rajnish','socialrajnish'); mysql('use rajnish_RITA');
% mysql('open','mysql','falk_public',''); mysql('use falk_RITA');
%     mysql('open','mysql','evgeny',''); mysql('use evgeny_RITA');
        % '95,100,102,103'
%     end
    
    % colors
    gbc = [1,1,1];
    gfc = [0.04 0.14 0.42];% [(hex2dec('01'))/255 (hex2dec('1b'))/255 (hex2dec('34'))/255];
    ghc = [0.4 0.2 0.2];
    bar_colors = [0.2 0.2 0.9; 0.2 0.2 0.5];
    listwidth = 120;
    barhandles = struct('handle',[]); % used to store handles of all bars
   

    
%% . load master data and set filters
    filters = struct();
    % load data
    [data, filters.all_recs] = LoadData(sessions);
    if( isempty(fieldnames(data)) )
        fprintf('no calls found!\n');
        return;
    end
    
    filters.active_recs = filters.all_recs;
    filters.count_recs = size(filters.all_recs,2);
    
    % load addl recording info
    [rec_info, paradigm] = RecInfo(sessions);
    
    filters.rec_on = 1:filters.count_recs;
    filters.active_recstring = cell(1,filters.count_recs);
    filters.rec_sessions = cell(1,filters.count_recs);
    for i=1:filters.count_recs
        filters.active_recstring(i) = {mat2str(filters.all_recs(i))};
        filters.rec_sessions(i) = {filters.active_recstring{i}(1:end-3)};
        filters.active_recstring(i) = strcat({filters.active_recstring{i}(1:end-3)}...
            ,'#',num2str(str2double(filters.active_recstring{i}(end-2:end)))...
            ,{'('}, paradigm(rec_info==filters.all_recs(i)),{')'}...
            );
    end
    
    % STC
    filters.clustertext = {''};
    filters.STC_on = [];
    % more STC data is added below (Section II B)
    
    % call types
    filters.calltypes = GetCallTypes();
    filters.active_calltypes = filters.calltypes.type_id( ...
            ~any(bsxfun(@eq, filters.calltypes.type_id, [7, 13, 14, 15, 16, 17]),2))';
    filters.count_calltypes = size(filters.calltypes.type_id,1);

    filters.modultype = unique(filters.calltypes.modulationtype);
    filters.modultypeid = 1:size(filters.modultype,1);
    filters.active_modultype = filters.modultypeid;
    filters.modultypestring = {'hmc','lmc','noi','oth'...
                    ;'high modulation','low modulation','noise','other'};
    for mt = 1:size(filters.calltypes.modulationtype,1)
        filters.calltypes.modulationtypeid(mt,1) = find( ...
            strcmp(filters.calltypes.modulationtype(mt),filters.modultype) ...
            ,1,'first');
    end
    
    % emitter
    filters.emitterstring = {'I','S','U';'Implanted','Stimulus','Unknown'};
    filters.emitterid =     [ 1   2   3 ];
    filters.active_emitter = filters.emitterid;

    % emitter sex
    filters.sexstring = {'f','m','-'};
    filters.sexid =     [ 1   2   3 ];
    filters.active_emisex = filters.sexid;

    % contact situation
    filters.contactstring = {'out','in'};
    filters.contactid =     [ 1   2  ];
    filters.active_contact = filters.contactid;  
    
    % implanted sex
    filters.impsexstring = {'f','m'};
    filters.impsexid =     [ 1   2 ];
    filters.active_impsex = filters.impsexid;
    filters.count_impsex = length(filters.impsexid);
    filters.rec_sex = zeros(1,filters.count_recs);
    for rc = 1:filters.count_recs
        filters.rec_sex(rc) = find(strcmp(filters.impsexstring ...
            , data(bsxfun(@eq,filters.all_recs(rc),[data(:).Rec_id])...
            ).sex),1,'first');
    end
    
    
    
    % histogram title info
    filters.shown_spikes = 0; % needs correction: does not differ for STC
    filters.shown_calls = 0;

    filters.ylim = 0.001;
    
%% _____________________________________________
%% --- II. main function ---
%% A: The Histogram
%% . main figure
    RITA_histogram_GUI = figure(...
            'Position',get( 0, 'ScreenSize' )...
            ,'WindowStyle','normal','Filename','myGui' ...
            ...,'MenuBar','none'... 
            ...,'Toolbar', 'none' ...
            ,'Name', 'RITA Spike histogram' ...
            ,'color',gbc...
            ,'DockControls', 'off'...
            ,'units','pixels' ...
            ,'Position',[32+listwidth 1 1024 round(1024*210/297)] ...
            ,'PaperType','A4' ...
            ,'PaperUnits','centimeters'...
            ...,'PaperPosition',[0 0 28.7 28.7*660/1024]...
            ,'PaperPositionMode','auto' ...
            ,'PaperOrientation','landscape'...
            ,'Resize', 'on' ...
            ,'Selected', 'on'...
            ,'visible','off' ...
            ,'DeleteFcn',@CloseAll ...
            );
    hold on;
    guipos = get(RITA_histogram_GUI,'position');
        
    
    histogram_panel = uipanel (...
            'parent',RITA_histogram_GUI...
            ,'Title',''...
            ,'BorderType','line'...
            ,'BorderWidth',2 ...
            ,'HighlightColor',ghc ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'Position',[0 0 1 1]);
    set(histogram_panel,'units','pixels');  

    filterlegend_height = 120; % bottom space for filter info
    histogrampos = get(histogram_panel,'position') + [80, filterlegend_height, -100, -80-filterlegend_height];    
    histogrampos2 = [histogrampos(1),       20+histogrampos(2)+histogrampos(4)*0 ...
                    , histogrampos(3)*0.7,      histogrampos(4)*1];
    rasterplotpos = [histogrampos2(1)+histogrampos2(3)+60,   histogrampos(2)+120, ...
                        histogrampos(3)-histogrampos2(3)-60,     histogrampos(4)-120];
%     inoutposition = [histogrampos2(1)+histogrampos2(3)+60,      20  ...
%                     , histogrampos(3)-histogrampos2(3)-60,      histogrampos(2)+60];
                
                
    % initialize histogram
    spikehistogram = axes('parent',histogram_panel...
            ,'units','pixels' ...
            ,'Position',histogrampos2...
            ,'FontSize',12.0 ...
            ,'XColor',gfc ...
            ,'YColor',gfc ...
            ,'YAxisLocation','left' ...
            ,'NextPlot','replacechildren' ...
            ...,'XGrid','on','YGrid','on' ...
            ...,'YLimMode','auto'...
            ,'visible','on' ...
            ,'tickdir','out'...
            ...,'XLim', [t_minus-binsize/2, t_plus-binsize/2] ...
            ...,'XTick', [t_minus-binsize/2, 0, t_plus-binsize/2]...
            ,'box','off' ...
            ,'ygrid','on' ...
            );

    % first, empty bar
    bar(0, 0,'parent',spikehistogram,'BarLayout','stacked','edgecolor',ghc);
    set(spikehistogram,'NextPlot','add'); 
    % NOTE: always keep track of 'NextPlot'. Great source of bugs.
    
    % histogram labelling
    xlabel(sprintf('time from call %s [ms]',trigger));
    ylabel('Spikes per call');
    histogramtitle = uicontrol('style','text' ...
            ,'string',sprintf('RITA spikes/calls analysis: sessions %s (%i calls shown)'...% , %i spikes 
               ,sessions, filters.shown_calls ... % , filters.shown_spikes
                )...
            ,'FontSize',12.0 ...
            ,'FontWeight','bold' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position',[histogrampos(1) histogrampos(2)+histogrampos(4)+30 histogrampos(3) 30]...
            );

%% . raster plot
    rasterplot = axes('parent',histogram_panel...
            ,'units','pixels' ...
            ,'Position',rasterplotpos...
            ,'FontSize',10.0 ...
            ,'XColor',gfc ...
            ,'YColor',gfc ...
            ,'YAxisLocation','left' ...
            ...,'NextPlot','replacechildren' ...
            ,'XGrid','on','YGrid','on' ...
            ...,'YLimMode','auto'...
            ,'visible','on' ...
            ,'tickdir','out'...
            ,'XLim', get(spikehistogram,'XLim') ...
            ,'XTick', get(spikehistogram,'XTick')...
            ...,'XTickLabel', get(spikehistogram,'XTickLabel')...
            ,'box','off' ...
            ,'ygrid','on' ...
            ); 
        set(rasterplot,'XLim', get(spikehistogram,'XLim'));
        
    
%     rastertitle = 
        uicontrol('style','text','parent',histogram_panel ...
            ,'position',[rasterplotpos(1),rasterplotpos(2)+rasterplotpos(4),rasterplotpos(3),20]...
            ,'string','spiketime detail'...
            ,'FontSize',10.0 ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            );

%     set(spikehistogram,'NextPlot','add'); 

%% . In/Out plot
%     inoutplot = axes('parent',histogram_panel...
%                     ,'units','pixels' ...
%                     ,'Position',inoutposition...
%                     ,'FontSize',10.0 ...
%                     ,'XColor',gfc ...
%                     ,'YColor',gfc ...
%                     ,'YAxisLocation','left' ...
%                     ,'XGrid','on','YGrid','on' ...
%                     ,'visible','on' ...
%                     ,'tickdir','out'...
%                     ,'box','off' ...
%                     ,'ygrid','on' ...
%                     ); 


%% . filter annotation
    filterlegend = struct();
    textelement_height = 16;
    textelement_posi = [histogrampos(1)     histogrampos(2)-30-textelement_height ...
                        histogrampos2(3)-60     textelement_height];
    % NOTE: "textelement_posi" is a position vector that is supposed to 
    %       move down as elements are added.

% Clusters
    filterlegend(2).h = uicontrol('style','text' ...
            ,'string', 'clusters: all' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', [textelement_posi(1:2), 560 , textelement_posi(4)]...
            );
    textelement_posi = [560 0 0 0] + textelement_posi;
    
    filterlegend(7).h = uicontrol('style','text' ...
            ,'string', '-' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', [textelement_posi(1:2), 100 , textelement_posi(4)]...
            );
                
    textelement_posi = [-560 -textelement_height 0 0] + textelement_posi;
    
% recordings  
    filterlegend(3).h = uicontrol('style','text' ...
            ,'string', 'recordings: all' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );
    textelement_posi = [0 -textelement_height 0 0] + textelement_posi;
    
% call types
    filterlegend(1).h = uicontrol('style','text' ...
            ,'string', 'call types: all' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );    
    textelement_posi = [400 0 0 0] + textelement_posi;
    
    filterlegend(8).h = uicontrol('style','text' ...
            ,'string', '-' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );
    textelement_posi = [-400 -textelement_height -120 0] + textelement_posi;
    
% emitter
    filterlegend(4).h = uicontrol('style','text' ...
            ,'string', 'emitter: all' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );
    textelement_posi = [+160 0 0 0] + textelement_posi;
    
% emitter sex
    filterlegend(5).h = uicontrol('style','text' ...
            ,'string', 'emitter sex: all' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );
                
    textelement_posi = [+160 0 0 0] + textelement_posi;
    
% contact
    filterlegend(6).h = uicontrol('style','text' ...
            ,'string', ' ' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );                
    textelement_posi = [-2*160 -textelement_height 0 0] + textelement_posi;

% subject rat
    filterlegend(9).h = uicontrol('style','text' ...
            ,'string', 'subject rat sex: all' ...
            ,'FontSize',8.0 ...
            ,'FontWeight','normal' ...
            ,'BackgroundColor',gbc ...
            ,'ForegroundColor',gfc ...
            ,'HorizontalAlignment','left' ...
            ,'units','pixels' ...
            ,'position', textelement_posi...
            );     
 

%% B: STC and Spikes Data
%% . get STC data
[STCdata, raw_spikes] = SpikesFromRITA(sessions);
    STC = [STCdata.Session_id, STCdata.Tetrode_id, STCdata.Cluster_id];
    raw_spikes = sortrows(raw_spikes,4);
%     raw_spikes(:,4) = raw_spikes(:,4)*100;

    [clusters, ~] = size(STC);


    filters.STC_all = 1:clusters;
    filters.STC_on = filters.STC_all;
    filters.STC_count = size(filters.STC_on,2);
    filters.active_STC_count = filters.STC_count;
    filters.STC_sessions = STCdata.Session_id;
    
    
    % brain region filter
    filters.all_brainregions = arrayfun(@(clu) regexp(STCdata.brain_structure{clu},',','split') ...
                                        , 1:clusters,'UniformOutput',false)';
    filters.all_brainregions = sort(unique(horzcat((filters.all_brainregions{:}))'));
    filters.all_brainregions = cellfun(@(br) strtrim(br), filters.all_brainregions,'UniformOutput',false);
    filters.all_brainregions = sort(unique(horzcat(filters.all_brainregions)'))';
    filters.active_brainregions = 1:size(filters.all_brainregions,1);
    
    % clusterwise info
    filters.clustertext = cell(clusters,1);
    filters.clustertext_short = cell(clusters,1);
    filters.brainRegions = cell(clusters,1);
    
    for i=1:clusters
        filters.clustertext{i} = strcat(num2str(STCdata.Session_id(i))...
                            ,{':TT'},num2str(STCdata.Tetrode_id(i))...
                            ,{':Cl'},num2str(STCdata.Cluster_id(i))...
                            ,{' ('},STCdata.brain_structure(i),{')'}...
                            ); 
        filters.clustertext_short{i} = strcat(num2str(STCdata.Session_id(i))...
                            ,{'/'},num2str(STCdata.Tetrode_id(i))...
                            ,{'/'},num2str(STCdata.Cluster_id(i))...
                            ); 
        currBrainRegions = regexp(STCdata.brain_structure(i),',','split');
        currBrainRegions = currBrainRegions{1};
        currBrainRegions = cellfun(@(x) strtrim(x), currBrainRegions,'UniformOutput',false);
        currBrainRegions = currBrainRegions(cellfun(@(x) ~isempty(x), currBrainRegions));
        
        filters.brainRegions(i) = {arrayfun(@(cbr) ...
                    find( strcmp(currBrainRegions(cbr),filters.all_brainregions),1,'first') ...
                    , 1:numel(currBrainRegions))};
        
    end %% cluster loop

    
    % unit type
    filters.unitstring = unique(STCdata.unit(:));
    filters.unit_count = size(filters.unitstring,1);
    filters.unit_id = 1:filters.unit_count;
    filters.active_unit = filters.unit_id;
    filters.all_units = zeros(1,size(STCdata.unit,1));
    for un = 1:size(STCdata.unit,1)
        filters.all_units(un) = find( ...
            strcmp(STCdata.unit(un),filters.unitstring) ...
            ,1,'first');
    end
    
    % cell type
    filters.celltypestring = unique(STCdata.cell_type(:));
    filters.celltype_count = size(filters.celltypestring,1);
    filters.celltype_id = 1:filters.celltype_count;
    filters.active_celltype = filters.celltype_id;
    filters.all_celltype = zeros(1,size(STCdata.cell_type,1));
    for cellty = 1:size(STCdata.cell_type,1)
        filters.all_celltype(cellty) = find( ...
            strcmp(STCdata.cell_type(cellty),filters.celltypestring) ...
            ,1,'first');
    end
    
%% . calculate spikes
    [spikes, times, callscount, spiketimes] = AddSpikes(STC);
    
%% . fill histogram and raster plot 
%     StapleUpHistogram(spikes, callscount);
    UpdateHistogram();
    set(RITA_histogram_GUI,'visible','on');
    
    % that red line
%     lineend = max(max(SumDimsBiggerN(spikes,2)));
%     stem([0 0],[0 lineend*1.2],'-','parent',spikehistogram,'color',[0.6 0.0 0],'marker','none');
%     


    
    
%  Initialization DONE here!
%  _____________________________________________ 
    
    
%% C: Filter Lists GUI
%% . filter figure
    filter_figure = figure(...
            'Position',get( 0, 'ScreenSize' )...
            ,'WindowStyle','normal','Filename','myGui' ...
            ,'MenuBar','none'... 
            ,'Toolbar', 'none' ...
            ,'Name', 'RITA histogram filters' ...
            ,'color',gfc+0.1...
            ,'DockControls', 'on'...
            ,'units','pixels' ...
            ,'Position',[10 1 listwidth guipos(4)] ...
            ,'Resize', 'off' ...
            ...,'Selected', 'off'...
            ,'visible','on' ...
            ,'DeleteFcn',@CloseAll ...
            );
   filter_selector = uipanel (...
            'parent',filter_figure...
            ,'units','normalized' ...
            ,'position',[0 0 1 1] ...
            ,'Title','filters'...
            ,'BorderType','line'...
            ,'BorderWidth',1 ...
            ,'HighlightColor',ghc ...
            ,'BackgroundColor',gfc ...
            ,'ForegroundColor',gbc ...
            );
    set(filter_selector,'units','pixels');       

    % NOTE: "lostpos" is a coordinate vector that is supposed to change as
    %       we add filter uicontrols
    listpos = get(filter_selector,'position');
    boxheight = 80;
    listpos = [listpos(1)+5 listpos(4)-boxheight-20 listpos(3)-10 boxheight];
    
    
%% . STC list

    uicontrol('style','text' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'String','STC info:' ...
             ,'visible','on' ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',8 ...
             ,'HorizontalAlignment', 'left' ...
             );
    listpos = listpos + [0 -20 0 0];  

%     ttcl_list = ...
    uicontrol('style','listbox' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'Callback', @ToggleSTC ...
             ,'value',filters.STC_on ...
             ,'max',2,'min',0 ...
             ,'String',[filters.clustertext{:}] ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ); 
    listpos = listpos + [0 -20 0 -boxheight+20];

%     unit_pop = ...
    uicontrol('style','popupmenu' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',listpos...
             ,'Callback', @ToggleUnit ...
             ,'value',1 ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.unitstring')' ...
             ,'BackgroundColor',gbc ...
             ,'ForegroundColor',gfc ...
             );

    listpos = listpos + [0 -20 0 0];
    
%     celltype_pop = ...    
        uicontrol('style','popupmenu' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',listpos...
             ,'Callback', @ToggleCellType ...
             ,'value',1 ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.celltypestring')' ...
             ,'BackgroundColor',gbc ...
             ,'ForegroundColor',gfc ...
             );

    listpos = listpos + [0 -boxheight-20 0 +boxheight];
    
    brainRegionPanel = uicontrol('style','listbox' ...
            ,'parent',filter_selector...
            ,'units','pixels'...
            ,'position',listpos ...
            ,'Callback', @ToggleBrainRegions ...
            ,'value',filters.active_brainregions ...
            ,'max',2,'min',0 ...
            ,'String',filters.all_brainregions ...
            ,'BackgroundColor',gfc ...
            ,'ForegroundColor',gbc ...
        );
         
    listpos = listpos + [0 -20 0 -boxheight];

%% . recordings list
    uicontrol('style','text' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'String','recording:' ...
             ,'visible','on' ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',8 ...
             ,'HorizontalAlignment', 'left' ...
             );
    listpos = listpos + [0 -boxheight 0 +boxheight-20];  
        
%     rec_list = ...
    uicontrol('style','listbox' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'Callback', @ToggleRec ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'value',filters.rec_on' ...
             ,'String',[filters.active_recstring(:)] ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ); %#ok<NBRAK>
    listpos = listpos + [0 -20-10 0 -boxheight+20];
        
%% implanted animal        
    uicontrol('style','text' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'String','subject rat:' ...
             ,'visible','on' ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',8 ...
             ,'HorizontalAlignment', 'left' ...
             );
             
    listpos = listpos + [0 -20 0 0];  
        
%      impsex_pop = ...
    uicontrol('style','popupmenu' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',listpos...
             ,'Callback', @ToggleImpSex ...
             ,'value',1 ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.impsexstring{:})' ...
             ,'BackgroundColor',gbc ...
             ,'ForegroundColor',gfc ...
             );
    listpos = listpos + [0 -20-10 0 0];                
        
%% . call type chooser
    uicontrol('style','text' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'String','call type:' ...
             ,'visible','on' ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',8 ...
             ,'HorizontalAlignment', 'left' ...
             );
    listpos = listpos + [0 -boxheight 0 +boxheight-20];  
        
%     calltype_list = ...
    uicontrol('style','listbox' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'Callback', @ToggleCallType ...
             ,'max',2,'min',0 ...
             ,'String',filters.calltypes.type ...
             ,'value',filters.active_calltypes ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',10 ...
             );     
    listpos = listpos + [0 -20 0 -boxheight+20];                
    
%     modultype_pop = ...
    uicontrol('style','popupmenu' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'Callback', @ToggleModulType ...
             ...,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.modultypestring{2,:})' ...
             ,'value',1 ...
             ,'visible','on' ...
             ...,'value',1:length(filt.eventtypes.type_id) ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ...,'FontSize',10 ...
             );
                             
    listpos = listpos + [0 -20-10 0 0];

%% . emitter specs        
    uicontrol('style','text' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'String','emitter:' ...
             ,'visible','on' ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',8 ...
             ,'HorizontalAlignment', 'left' ...
             );
    listpos = listpos + [0 -20 0 0]; 
    
%     emitter_pop = ...
    uicontrol('style','popupmenu' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',[listpos(1) listpos(2) listpos(3) 20]...
             ,'Callback', @ToggleEmitter ...
             ,'value',1 ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.emitterstring{2,:})' ...
             ,'BackgroundColor',gbc ...
             ,'ForegroundColor',gfc ...
             );


    listpos = listpos + [0 -20 0 0];
%     emisex_pop = ...
    uicontrol('style','popupmenu' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',[listpos(1) listpos(2) listpos(3) 20]...
             ,'Callback', @ToggleEmiSex ...
             ,'value',1 ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.sexstring{:})' ...
             ,'BackgroundColor',gbc ...
             ,'ForegroundColor',gfc ...
             );
    listpos = listpos + [0 -20-10 0 0];
    
    uicontrol('style','text' ...
             ,'parent',filter_selector ...
             ,'units','pixels'...
             ,'position',listpos ...
             ,'String','contact:' ...
             ,'visible','on' ...
             ,'BackgroundColor',gfc ...
             ,'ForegroundColor',gbc ...
             ,'FontSize',8 ...
             ,'HorizontalAlignment', 'left' ...
             );
    listpos = listpos + [0 -20 0 0]; 
    
    
%     context_pop = ...
    uicontrol('style','popupmenu' ...
             ,'parent',filter_selector...
             ,'units','pixels'...
             ,'position',[listpos(1) listpos(2) listpos(3) 20]...
             ,'Callback', @ToggleContact ...
             ,'value',1 ...
             ,'visible','on' ...
             ,'max',2,'min',0 ...
             ,'String',horzcat({'all'},filters.contactstring{:})' ...
             ,'BackgroundColor',gbc ...
             ,'ForegroundColor',gfc ...
             );


%% _____________________________________________
%% --- III. GUI callbacks ---
 
%% . Call Types
    function ToggleCallType(calltype_list,~)
        filters.active_calltypes = get(calltype_list,'value');
        UpdateHistogram();

    end % end ToggleCalltype

    function ToggleModulType(modultype_pop,~)
        mod = get(modultype_pop,'value');
        switch mod;
            case 1
                filters.active_modultype = filters.modultypeid;
            otherwise
                filters.active_modultype = filters.modultypeid(mod-1);
        end
        
        UpdateHistogram();

    end % end ToggleModulation
    
%% . STC entries
    function ToggleSTC(ttcl_list,~) % [STC_on] =

        filters.STC_on = get(ttcl_list,'value');
        filters.STC_count = size(filters.STC_on,2);
        UpdateHistogram();

    end % end ToggleBar

    function ToggleUnit(unit_pop,~)
        unit = get(unit_pop,'value');
        switch unit;
            case 1
                filters.active_unit = filters.unit_id;
            otherwise
                filters.active_unit = filters.unit_id(unit-1);
        end
        
        UpdateHistogram();

    end % end ToggleEmitter

    function ToggleCellType(celltype_pop,~)
        ct = get(celltype_pop,'value');
        switch ct;
            case 1
                filters.active_celltype = filters.celltype_id;
            otherwise
                filters.active_celltype = filters.celltype_id(ct-1);
        end
        
        UpdateHistogram();

    end % end ToggleEmitter

    function ToggleBrainRegions(~,~)
        filters.active_brainregions = get(brainRegionPanel,'value');

        UpdateHistogram();
    end % ToggleBrainRegion


%% . Recordings
    function ToggleRec(rec_list,~)
        filters.rec_on = get(rec_list,'value');
        filters.active_recs = filters.all_recs(filters.rec_on);
        
        UpdateHistogram();

    end % end ToggleBar

%% . Emitter
    function ToggleEmitter(emitter_pop,~)
        emi = get(emitter_pop,'value');
        switch emi;
            case 1
                filters.active_emitter = filters.emitterid;
            otherwise
                filters.active_emitter = filters.emitterid(emi-1);
        end
        
        UpdateHistogram();

    end % end ToggleEmitter

%% . Emitter Sex
    function ToggleEmiSex(emisex_pop,~)
        sex = get(emisex_pop,'value');
        switch sex;
            case 1
                filters.active_emisex = filters.sexid;
            otherwise
                filters.active_emisex = filters.sexid(sex-1);
        end
        
        UpdateHistogram();

    end % end ToggleEmiSex

%% . contact
    function ToggleContact(contact_pop,~)
        con = get(contact_pop,'value');
        switch con;
            case 1
                filters.active_contact = filters.contactid;
            otherwise
                filters.active_contact = filters.contactid(con-1);
        end
        
        UpdateHistogram();

    end % end ToggleEmiSex

%% . Implanted Sex
    function ToggleImpSex(impsex_pop,~)
        sex = get(impsex_pop,'value');
        switch sex;
            case 1
                filters.active_impsex = filters.impsexid;
            otherwise
                filters.active_impsex = filters.impsexid(sex-1);
        end
        
        UpdateHistogram();

    end % end ToggleimpSex

%  _____________________________________________


%% _____________________________________________
%% --- IV. The Spike Machinery ---

%% A: Add Spikes
    function [spikes, times, callscount, spiketimes] = AddSpikes(STC) % , stimsex
%% . optionally load spikes        
        existing_spikes = questdlg('open existing spike data?','RITA spike loader','yes','no','no'); 
        switch existing_spikes
            case 'yes'
                [filename, pathname] = uigetfile( ...
                    {  '*.mat','MAT-files (*.mat)'; ...
                       '*.*',  'All Files (*.*)'}, ...
                       'Select spike file');
                   if isequal(filename,0)
                       msgbox('no file selected','RITA Spikes Histogram');
                    else
                       the_loaded = load(strcat(pathname,filename),'sessions','spikes','times','callscount','filters','spiketimes');
                           sessions = the_loaded.sessions;
                           spikes = the_loaded.spikes;
                           callscount = the_loaded.callscount;
                           filters = the_loaded.filters;
                           spiketimes = the_loaded.spiketimes;
                           times = the_loaded.times;
                           
                       % reload data as if it were new
                       [data, filters.all_recs] = LoadData(sessions);
                       filters.active_recs = filters.all_recs;
                       set(histogramtitle,'string',sprintf('RITA spikes/calls analysis: sessions %s (%i calls shown)'...% , %i spikes
                           ,sessions, filters.shown_calls ... % , filters.shown_spikes
                            ));

                       clear the_loaded;
                       return;
                   end % filename
        end % switch user choice
        
        % that ugly red bar...
        sWait = waitbar(0,'Loading Spikes of ');

%% . initialize spikes
        spikes = zeros(clusters,bin_count...
                        ,length(filters.all_recs)...
                        ,length(filters.calltypes.type_id)...
                        ,length(filters.emitterid)...
                        ,length(filters.sexid)...
                        ,length(filters.contactid) ...
                        );
        callscount = zeros( ...
                        length(filters.all_recs)...
                        ,length(filters.calltypes.type_id)...
                        ,length(filters.emitterid)...
                        ,length(filters.sexid)...
                        ,length(filters.contactid) ...
                        );
        times = zeros(size(callscount));
        
        counter = 0;

        
        for rec=1:length(data)     
%% . scan through spikes near events
            for dat=1:length(data(rec).start_time)
                waitbar(dat/length(data(rec).start_time),sWait,sprintf('recording %i (%i/%i), %i%%',data(rec).Rec_id,rec,length(data),round(100*dat/length(data(rec).start_time))))              


                typ = data(rec).type_id(dat);
                recding = find(data(rec).Rec_id == filters.all_recs,1);
                emi = filters.emitterid(cellfun( @(emifil)strcmpi(emifil, data(rec).emitter(dat)), filters.emitterstring(1,:) ));
                if ( cellfun(@(emit)strcmpi(emit,'L'),data(rec).emitter(dat)) || cellfun(@(emit)strcmpi(emit,'R'),data(rec).emitter(dat)) )
                    emi = find(strcmp(filters.emitterstring(1,:), 'S'),1);
                end
                emisex = filters.sexid(cellfun( @(sexfil)strcmpi(sexfil, data(rec).emsex(dat)), filters.sexstring ));
                con = filters.contactid(cellfun( @(confil)strcmpi(confil, data(rec).contact(dat)), filters.contactstring ));


                callscount(recding,typ,emi,emisex,con) =  ...
                                1 + callscount(recding,typ,emi,emisex,con);
                times(recding,typ,emi,emisex,con) =  ...
                                times(recding,typ,emi,emisex,con) ...
                                    + binsize / 1000;


%% . choose start or end
                if (strcmp(trigger,'end'))
                    events = timeinterval + data(rec).end_time(dat);
                    pointzero = data(rec).end_time(dat);
                    less_raw_spikes = raw_spikes( (raw_spikes(:,4) >= data(rec).end_time(dat) + t_minus) ...
                    & (raw_spikes(:,4) <= data(rec).end_time(dat) + t_plus) , :);
                else 
                    events = timeinterval + data(rec).start_time(dat);
                    pointzero = data(rec).start_time(dat);
                    less_raw_spikes = raw_spikes( (raw_spikes(:,4) >= data(rec).start_time(dat) + t_minus) ...
                    & (raw_spikes(:,4) <= data(rec).start_time(dat) + t_plus) , :);
                end
                  

                    
%% . loop thru STC
                for clu=1:clusters

                    % find STC position
                        % TODO: performance optimization right here
                    check = boolean((less_raw_spikes(:,1)==data(rec).Session_id))...
                        & (less_raw_spikes(:,1) == STC(clu,1))...
                        & (less_raw_spikes(:,2) == STC(clu,2))...
                        & (less_raw_spikes(:,3) == STC(clu,3));

                    % get coordinates
                    relevant_spikes = less_raw_spikes(check,4);
                    
                    % sum up spikes
                    for bin = 1:bin_count
                        spikes(clu,bin,recding,typ,emi,emisex,con) =  ...
                                        spikes(clu,bin,recding,typ,emi,emisex,con) ...
                                            + sum((relevant_spikes >= events(bin)) ...
                                            & (relevant_spikes < events(bin)+binsize));
                    end

                    
%                     if(~isempty(relevant_spikes))
                    counter = counter + 1;
                    spiketimes(counter) = struct('clu',clu ...
                          , 'vis',1 ...
                          , 'rec',recding ...
                          , 'typ',typ ...
                          , 'emi',emi ...
                          , 'emisex',emisex ...
                          , 'contact',con ...
                          , 'spikes',relevant_spikes - pointzero ...
                          ); %#ok<AGROW>
%                     end
                    
                end % end: loop thru STC
                
            end % end: loop thru events
        end % end: loop thru data
        
        % Echo Success
        waitbar(1,sWait,'Done!')
        delete(sWait)
        
        
%% . optionally save spikes
        
        filters.today = datevec(date());
        filters.today = sprintf('%04.0f%02.0f%02.0f',round(filters.today(1)),filters.today(2),filters.today(3));

        savename = strcat(pwd(),'/',filters.today,'_cs_',sessions,'_s',num2str(t_minus/1000),'to',num2str(t_plus/1000),'.mat');
         
        save_spikes = questdlg('save spike data for later?','RITA spike loader','yes','no','no'); 
        switch save_spikes
            case 'yes'
                [filename, pathname] = uiputfile( ...
                            {  '*.mat','MAT-files (*.mat)'; ...
                               '*.*',  'All Files (*.*)'}, ...
                               'save spike file',savename);
                           if isequal(filename,0)
                               msgbox(sprintf('No file specified.\nsaved as %s.',savename),'RITA Spikes Histogram');
                               filename = savename;
                           end
                 save(strcat(pathname,filename),'sessions','spikes','times','callscount','filters','spiketimes');
        end
    end % end AddSpikes


%% C: Multi-Dimensional Operations
%% . filter dimensions

%% . sum/mean over multiple dimensions
function [multimatrix] = SumDimsBiggerN(multimatrix, n_max)

    for d=ndims(multimatrix):-1:(n_max+1)
        multimatrix=sum(multimatrix,d);
    end
    
end % end SumDimsFrom3
% function [multimatrix] = MeanDimsBiggerN(multimatrix, n_max)
% 
%     for d=ndims(multimatrix):-1:(n_max+1)
%         multimatrix=sum(multimatrix,d) ./ any(multimatrix ~= 0,d);
%         multimatrix(isnan(multimatrix))=0;
%     end
%     
% end % end MeanDimsFrom3




%  _____________________________________________


%% _____________________________________________
%% --- V. Keep Your Histogram Beautiful ---

%% . update histogram bars
    function UpdateHistogram()
        
        impsex_filter = any(bsxfun(@eq...
                ,filters.rec_sex .* any(bsxfun(@eq, filters.active_recs , filters.all_recs'),2)' ...
                ,filters.active_impsex'),1);
        ct_filter =  ...
                any(bsxfun(@eq, filters.calltypes.modulationtypeid ,filters.active_modultype),2) ...
                & any(bsxfun(@eq,filters.calltypes.type_id(:),filters.active_calltypes),2);
        emi_filter = any(bsxfun(@eq,filters.emitterid',filters.active_emitter),2);
        emisex_filter = any(bsxfun(@eq,filters.sexid',filters.active_emisex),2);
        contact_filter = any(bsxfun(@eq,filters.contactid',filters.active_contact),2);
        
        brainregion_filter = arrayfun(@(cel) any( ...
                            bsxfun(@eq, filters.brainRegions{cel}, filters.active_brainregions) ...
                            ,2) , 1:size(filters.brainRegions,1))';
        
        stc_filter = any(bsxfun(@eq, filters.STC_all', filters.STC_on),2) ...
            & any(bsxfun(@eq, filters.all_units', filters.active_unit),2)... 
            & any(bsxfun(@eq, filters.all_celltype', filters.active_celltype),2)...
            & brainregion_filter ... & any(bsxfun(@eq, filters.brainRegions( ...
            ;
        
        
        rec_filter = impsex_filter' & any(bsxfun(@eq,[data(:).Rec_id]',filters.active_recs),2);
        if(isempty(rec_filter)) % if all recs deselected for some reason
            rec_filter = zeros(filt.count_recs,1);
        end
        
        % adjust rec_filter for constraints of emitter and emitter sex
        emitter_counter = arrayfun(@(da) unique(data(da).emitter(:)), 1:size(data,2)...
                    , 'UniformOutput', false);
        for re = 1:size(emitter_counter,2)
            emitter_counter{re}(strcmp('L',emitter_counter{re})) = {'S'};
            emitter_counter{re}(strcmp('R',emitter_counter{re})) = {'S'};
            emitter_counter(re) = {unique(emitter_counter{re})};
        end
        
        emitter_counter = cell2mat(arrayfun(@(re) ...
                    any(cell2mat(arrayfun(@(emi) strcmp(emitter_counter{re}(emi), filters.emitterstring(1,:)) ...
                                , 1:size(emitter_counter{re}), 'UniformOutput', false)'),1) ...
                    , 1:filters.count_recs, 'UniformOutput', false)')...
                ;
        
        emisex_counter = cellfun(@(reems) cellfun(@(re) strcmp(re,filters.sexstring) ...
                    , reems, 'UniformOutput', false) ...
                , arrayfun(@(da) unique(data(da).emsex(:)), 1:size(data,2)...
                    , 'UniformOutput', false) ...
                , 'UniformOutput', false);
        emisex_counter = ...
            cell2mat(cellfun(@(inp) any(inp,1), ...
                cellfun(@cell2mat, emisex_counter, 'UniformOutput', false) ...
            , 'UniformOutput', false)');
        
        % adjust rec_filter for constraints of STC selection
        stc_counter = bsxfun(@eq, str2double(filters.rec_sessions(:)) ...
                                , unique(filters.STC_sessions(stc_filter)'));
        % final rec filter
        rec_filter = boolean(rec_filter ...
                            .* any(emitter_counter(:,emi_filter),2) ...
                            .* any(emisex_counter(:,emisex_filter),2) ...
                            .* any(stc_counter,2) ...
                            );
        
        time1d = SumDimsBiggerN(times( ...
                : ...
                , ct_filter ...
                , emi_filter ...
                , emisex_filter ...
                , contact_filter ...
                ),1 );
        
        call1d = SumDimsBiggerN(callscount( ...
                : ...
                , ct_filter ...
                , emi_filter ...
                , emisex_filter ...
                , contact_filter ...
                ),1 );
        filters.shown_calls = sum(call1d(rec_filter));
            
        

        spc2d = SumDimsBiggerN(spikes( ...
                :, : ...
                , rec_filter ...
                , ct_filter ...
                , emi_filter ...
                , emisex_filter ...
                , contact_filter ...
            ),2) ...
            ./ sum(sum(time1d(rec_filter))) ...
            ;
        spc2d(isinf(spc2d)) = 0;
        
        % update all active bars
        filters.active_STC_count = sum(stc_filter);
        UpdateClusterBars(spc2d(stc_filter,:)');

        

        UpdateFilterLegendText(stc_filter,ct_filter);
        RasterUpdate(stc_filter,ct_filter);
        
        set(histogramtitle,'string',sprintf('RITA spikes/calls analysis: sessions %s (%i calls shown)'...% , %i spikes
                   ,sessions, filters.shown_calls ... % , filters.shown_spikes
                    ));

    end % end Update Histogram Bars




    function UpdateClusterBars(SpikesPerCluster)
        cla(spikehistogram);
        
         if(0 == filters.active_STC_count)
            SpikesPerCluster = zeros(1,size(SpikesPerCluster,1));
            barhandles.handle = bar(...
                        SpikesPerCluster...
                        ,'parent',spikehistogram,'BarLayout','stacked');
            return;
        end
    
        barhandles.handle = bar(...
                                SpikesPerCluster...
                                ,'parent',spikehistogram,'BarLayout','stacked');
        
        % stack up bar plots and return handle
        for b = 1:filters.active_STC_count
            set(barhandles.handle(b),'FaceColor',bar_colors(mod(b,2)+1,:));
            
        end
        
        % histogram x labels
        decimal_order = round(log10(max(sum(SpikesPerCluster,2))));
        if(isnan(decimal_order) || isinf(decimal_order))
            decimal_order=-3;
        end
        
        filters.ylim = max(sum(SpikesPerCluster,2))*1.02+10^(decimal_order-1);
        if(isnan(filters.ylim))
            filters.ylim = 0.001;
        end
        
        warning('off','MATLAB:colon:nonIntegerIndex');
        set(spikehistogram ...
            ,'xlim', [0.5,bin_count+0.5] ...
            ,'xtick', unique([0.5:tick:bin_count,bin_count+0.5]) ...
            ,'xticklabel',unique([t_minus:binsize*tick:t_plus, t_plus]) ...
            ,'YLim',[0, filters.ylim] ...
            ,'box','off' ...
            );
                
        warning('on','MATLAB:colon:nonIntegerIndex');
        % that red line
        stem_x_position = 0.5 + bin_count * abs(min(timeinterval))/(max(timeinterval)-min(timeinterval));
        stem([stem_x_position stem_x_position],[0 filters.ylim],'-' ...
            ,'parent',spikehistogram,'color',[0.4 0.0 0.0],'marker','none');
    
        
    end

%% D: raster update

    function RasterUpdate(active_cells,ct_filter)
        % clean up
        cla(rasterplot,'reset');
        y = 0;
        [~,cl] = size(spiketimes);
        
        for call=1:cl
            
            try
            check = 0 || ~max(spiketimes(call).clu == filters.STC_all(active_cells)) ...
                          || ~max(spiketimes(call).rec == filters.rec_on)...
                          || ~max(spiketimes(call).typ == filters.calltypes.type_id(ct_filter))...
                          || ~max(spiketimes(call).emi == filters.active_emitter)...
                          || ~max(spiketimes(call).emisex == filters.active_emisex)...
                          || ~max(spiketimes(call).contact == filters.active_contact)...
                          ;
                      
            catch err
                if(strcmp(err.identifier,'MATLAB:dimagree'))
                    check = 1;
                end
            end                
            
            if(~exist('check','var')||check) 
                continue; 
            end

            for spik = 1:length(spiketimes(call).spikes)
                spikestamp = spiketimes(call).spikes(spik);
                line('xdata',[spikestamp, spikestamp],'ydata', [y y+1],'parent',rasterplot ...
                    ,'LineWidth',1,'color',gfc+0.4);
            end
            y = y + 1;
        end % loop thru calls
        
        % polish plot
%         filters.shown_calls = y / filters.active_STC_count;
        y = max([y,1]);
        set(rasterplot,'ylim',[0 y]...
            ,'XLim', [t_minus, t_plus] ...
            ,'YGrid','on'...,'XGrid','on'
            ,'XColor',gfc ...
            ,'YColor',gfc... 
            );
        
        
        line([0 0],[0 y],'linestyle',':','parent',rasterplot,'color',[0.4 0.0 0]);
        
    end


%% . update text in filter legend
    function UpdateFilterLegendText(active_cells,ct_filter)
        % call types
            call_type_text = ConcatFilters(filters.calltypes.type,filters.calltypes.type_id(ct_filter));
            set(filterlegend(1).h,'string',sprintf('call types:%s',call_type_text));
        % STC
            cluster_text = ConcatFilters(filters.clustertext_short,filters.STC_all(active_cells));
            set(filterlegend(2).h,'string',sprintf('clusters:%s',cluster_text));
        % STC groups
            STC_text = strcat(ConcatFilters(filters.unitstring,filters.active_unit), ...
                ConcatFilters(filters.celltypestring,filters.active_celltype) );
            if(strcmp(STC_text,' all all'))
                STC_text = '';
            end
            set(filterlegend(7).h,'string',sprintf('%s',STC_text));
            
        % recordings
            rec_text = ConcatFilters(filters.active_recstring',filters.rec_on);
            set(filterlegend(3).h,'string',sprintf('recordings:%s',rec_text));
        % emitter
            emi_text = ConcatFilters(filters.emitterstring(2,:),filters.active_emitter);
            set(filterlegend(4).h,'string',sprintf('emitter:%s',emi_text));
        % emitter sex
            emisex_text = ConcatFilters(filters.sexstring,filters.active_emisex);
            set(filterlegend(5).h,'string',sprintf('emitter sex:%s',emisex_text));
        % contact situation
            contact_text = ConcatFilters(filters.contactstring,filters.active_contact);
            if (strcmp(contact_text, ' all,'))
                set(filterlegend(6).h,'string',' ');
            else
                set(filterlegend(6).h,'string',sprintf('%s contact',contact_text));
            end
        % call modulation type
            modtype_text = '-';
            if (~(size(filters.active_modultype,2)>1))
                modtype_text = filters.modultypestring{2,filters.active_modultype};
            end
            set(filterlegend(8).h,'string',sprintf('%s',modtype_text));
        % subject rat
            rat_text = ConcatFilters(filters.impsexstring',filters.active_impsex);
            set(filterlegend(9).h,'string',sprintf('subject rat sex: %s',rat_text));
            
    end % end UpdateFilterLegendText


%% . filter texts
function [ filtertext ] = ConcatFilters(textlist,selectedelements)
    filtertext = {''};
    if length(textlist) == length(selectedelements)
        filtertext = {' all,'};
    else
        shortlist = textlist(selectedelements);
        for fil=1:length(shortlist)
            filtertext = strcat(filtertext, {' '}, shortlist{fil}, ',');
        end
        
    end
    filtertext = filtertext{1};
    filtertext = filtertext(1:end-1);
end % ConcatFilters


%% . reset axis limits
%     function ResetYLim()
%         [data_m,data_n,~,~,~,~] = size(spikes);
%         maxspikes = zeros(1,data_n);
%         for b = 1:data_m
%             if(strcmp(get(barhandles(b).handle,'visible'),'on'))
%             maxspikes = maxspikes + get(barhandles(b).handle,'ydata' );
%             end
%         end
%         try
%             set(spikehistogram,'ylim',[0, min([lineend, max([maxspikes,1])])*1.05])
%         catch err
%             if(strcmp(err.identifier,'MATLAB:hg:propswch:PropertyError'))
%                 disp('no spikes found for any calls');
%             end
%         end     
%         
%     end % end ResetYLim


%% . lbnl: close beautifully
    function CloseAll(~,~)
        if(exist('RITA_histogram_GUI','var'))
            delete(RITA_histogram_GUI);

        end
        if(exist('filter_selector','var'))
            delete(filter_figure);

        end

        mysql('close');
        clear all;
        
    end % end CloseAll
%  _____________________________________________


end % end main
% ############  end of main function ###########
%  _____________________________________________




%% _____________________________________________
%% --- VI. SQL queries to RITA---

%% A: Load USV Data
function [usv, all_recs] = LoadData(sessions)
hWait = waitbar(0,'getting spikes (SQL query)...');
%% . count recs
    Recs = mysql(['SELECT DISTINCT Rec_id FROM Rec'...
                ' WHERE Session_id IN (',sessions,')'... % 18, 19, 102, 103
                ' GROUP BY Rec_id'...
                ' ORDER BY Rec_id'...
                ]);
    usv = struct();
    empties = 0;

    for i=1:length(Recs)
    waitbar(i/length(Recs),hWait,sprintf('Loading Recording %i',Recs(i)))    

    
%% . skip empty recs
        s = i - empties;
    if ( isempty(mysql(['SELECT DISTINCT Rec_id FROM USV'...
                        ,' WHERE Rec_id = ',num2str(Recs(i))...
                        ,' GROUP BY Rec_id ']))...
                    )
        empties = empties + 1;
        continue;
    end

%% . data query
     [  ... % unique values for whole recd
         Session_id... 
        ,date...
        ,Rec_id...
        ,paradigm...
        ,recording_start...
        ,recording_end...
        ,USV_data ...
        ... % calls
        ,usv(s).type_id... 
        ,usv(s).calltype... 
        ,usv(s).callabbr... 
        ,usv(s).modultype... 
        ,usv(s).start_time...
        ,usv(s).end_time...
        ,usv(s).side...*
        ,usv(s).emitter...*
        ,usv(s).emsex...*
        ,usv(s).recipsex...*
        ,sex...
        ,usv(s).contact...
    ] = mysql(['SELECT  '...
    '	Recording.Session_id '...
    '	, Recording.date '...
    '	, Recording.Rec_id '...
    '	, Recording.paradigm '...
    '	, Recording.start_time AS recording_start '...
    '	, Recording.end_time AS recording_end '...
    '	, Recording.USV_data '...
    '	, USV.type_id + 1 AS type_id '...
    '	, Call_type.call_type '...
    '	, Call_type.abbr '...
    '	, Call_type.modulation_type '...
    '	, USV.Nlx_adjusted AS start_time '...
    '	, USV.Nlx_time + USV.duration AS end_time '...
    '	, USV.side '...
    '	, USV.emitter '...
    '	, USV.emitter_sex '...
    '	, USV.recipient_sex '...
    '   , Recording.sex '...
    '	, CASE WHEN USV.contact = 0 THEN ''out'' ELSE ''in'' END AS contactstr '...
    'FROM USV '...
    'LEFT JOIN Call_type ON Call_type_id = USV.type_id '...
    'LEFT JOIN ( '...
    '	SELECT Rec.Rec_id '...
    '			,Rec.Session_id '...
    '			, Rec.paradigm '...
    '			, Rec.start_time '...
    '			, Rec.end_time '...
    '			, Rec.note '...
    '			, Session.date '...
    '           , Rec.USV_data '...
    '           , Rats.sex '...
    '	FROM Rec '...
    '	LEFT JOIN Session	ON Rec.Session_id = Session.Session_id '...
    '   LEFT JOIN Rats	ON (Session.rat_id = Rats.Rats_id AND Rats.purpose = ''implanted'')'...
    '	) AS Recording '...
    '	ON USV.Rec_id = Recording.Rec_id '...
    'WHERE 	Session_id IS NOT NULL '...
    '  AND  USV.Rec_id = ',num2str(Recs(i))   ... %AND	Recording.Session_id IN (',num2str(sessions) ,')'...
    '  AND Call_type.abbr NOT LIKE ''mdi'' ' ...
    ]);
    
    % add unique values to struct
    usv(s).Session_id = unique(Session_id);
        usv(s).date = unique(date);
        usv(s).Rec_id = unique(Rec_id);
        usv(s).paradigm = unique(paradigm);
        usv(s).recording_start = unique(recording_start);
        usv(s).recording_end = unique(recording_end);
        usv(s).data_acquired = unique(USV_data);
        usv(s).sex = unique(sex);

    
%% . check if actually data came out
            % known issues: wrong 'obj'/'rat' tag in "Stimuli"
        if( isempty(fieldnames(usv(s))) || isempty(usv(s).Rec_id) ) 
            if(usv(s).data_acquired)
                fprintf('Rec#%i \n \t Three things are certain: \n \t Death, taxes, and lost data. \n \t Guess which has occurred. \n',Recs(i));
            end
            empties = empties + 1;
            usv(s) = [];
        end
    
    end % end "Recs" for loop

%% . cleanup
    waitbar(1,hWait,'finished loading call data');
    delete(hWait); 
    
    
    all_recs = zeros(1, length(usv));
    if ( ~isempty(fieldnames(usv)) )
        for call=1:length(usv)
            all_recs(1,call) = usv(call).Rec_id;
        end    
    end
    all_recs = unique(all_recs);
    
    
end % end LoadData
%  _____________________________________________



%  _____________________________________________
%% B: Spikes from RITA
    function [STCdata, raw_spikes] = SpikesFromRITA(sessions)
%% . fill STC table
    STCdata = struct();
        [ ...
         STCdata.Session_id ...
         , STCdata.Tetrode_id ...
         , STCdata.Cluster_id ...
         , STCdata.unit ...
         , STCdata.cell_type ...
         , STCdata.brain_structure ...
         ] = mysql( ['SELECT DISTINCT' ...
                     '     STC.Session_id AS ses' ...
                     '   , STC.Tetrode_id AS tet' ...
                     '   , STC.Cluster_id AS clu' ...
                     '   , STC.unitInfo AS unit' ...
                     '   , STC.cell_type AS cell_type' ...
                     '   , STC.brain_structure AS brain_structure' ...
                     ' FROM ' ...
                     '   STC' ...
                     ' WHERE ' ...
                     '   STC.Session_id IN (',num2str(sessions) ,')' ...
                     ' GROUP BY ses, tet, clu, unit, cell_type, brain_structure'...
                     ]);
     
%% . load all spikes of a session                   
    [ses, tet, clu, Nlx] = mysql( ['SELECT' ...
                             '     STC.Session_id AS ses' ...
                             '   , STC.Tetrode_id AS tet' ...
                             '   , STC.Cluster_id AS clu' ...
                             '   , Nlx_time AS Nlx' ...
                             ' FROM ' ...
                             '   STC' ...
                             ' LEFT JOIN Spikes' ...
                             '   ON (STC.Session_id = Spikes.Session_id' ...
                             '   AND STC.Tetrode_id = Spikes.Tetrode_id' ...
                             '   AND STC.Cluster_id = Spikes.Cluster_id' ...
                             '   )' ...
                             ' WHERE ' ...
                             '   STC.Session_id IN (',num2str(sessions) ,')' ...
                     ]);
                 
     raw_spikes = [ses tet clu (double(Nlx))];

     
    end % end SpikesFromRITA
%  _____________________________________________


%  _____________________________________________
%% C: Misc Short Queries
%% . recording info from RITA
    function [rec_id,paradigm] = RecInfo(sessions)
                   
    [rec_id, paradigm] = mysql( ['SELECT DISTINCT Rec_id, paradigm '...
                             'FROM Rec '...
                             'WHERE Session_id IN (',num2str(sessions) ,') '...
                             'GROUP BY Rec_id, paradigm '...
                             'ORDER BY Rec_id ' ...
                     ]);

    end % end Rec_Info
%  _____________________________________________


%  _____________________________________________
%% . call types
    function [calltypes] = GetCallTypes()
        calltypes = struct();
        [...
            calltypes.type_id ...
            , calltypes.abbr ...
            , calltypes.type ...
            , calltypes.modulationtype ...
        ] = mysql( ['SELECT  ' ...
                             '	Call_type_id ' ...
                             '	, abbr ' ...
                             '	, call_type ' ...
                             '	, modulation_type ' ...
                             ' FROM Call_type ' ...
                             ' ORDER BY Call_type_id ASC ' ...
                     ]);
        calltypes.type_id = calltypes.type_id+1; % no zero

    end % GetCallTypes
    
%% _____________________________________________

%% --- VII. Notes ---


%% __________________________________________eof